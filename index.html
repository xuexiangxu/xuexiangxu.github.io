<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Xuexiang&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Xuexiang&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Xuexiang&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="xuexiangxu">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Xuexiang's Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<!-- hexo injector head_end start --><script type="module" src="https://cdn.jsdelivr.net/npm/mermaid@latest/dist/mermaid.esm.min.mjs">
    mermaid.initialize(
      startOnLoad: true,
    );
    </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Xuexiang&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-dom-event-target" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/02/14/dom-event-target/" class="article-date">
  <time class="dt-published" datetime="2025-02-14T16:38:47.000Z" itemprop="datePublished">2025-02-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/02/14/dom-event-target/">event.target 和 event.currentTarget</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><code>event.target</code> 和 <code>event.currentTarget</code> 都是事件对象 (<code>event</code>) 的属性，它们都可以用来获取事件的目标元素，但有以下关键区别：</p>
<h3 id="1-event-target"><a href="#1-event-target" class="headerlink" title="1. event.target"></a>1. <code>event.target</code></h3><ul>
<li><code>event.target</code> 返回的是<strong>触发事件的实际元素</strong>，即事件的<strong>目标元素</strong>。</li>
<li>这是事件冒泡过程中的那个元素，通常是用户与之交互的元素（如按钮、链接、输入框等）。</li>
</ul>
<p><strong>例子</strong>：<br>假设有以下 HTML 结构：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;child&quot;</span>&gt;</span>点击我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>并且为父元素和子元素绑定了事件监听器：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;parent&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">target</span>);  <span class="comment">// 打印触发事件的实际元素</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>当点击 <code>button</code> 时，<code>event.target</code> 会输出：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;child&quot;</span>&gt;</span>点击我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这是因为 <code>button</code> 元素是触发事件的目标。</p>
<h3 id="2-event-currentTarget"><a href="#2-event-currentTarget" class="headerlink" title="2. event.currentTarget"></a>2. <code>event.currentTarget</code></h3><ul>
<li><code>event.currentTarget</code> 返回的是<strong>当前处理事件的元素</strong>，即事件监听器绑定的元素。</li>
<li>无论事件是从哪个元素触发的，<code>currentTarget</code> 始终指向当前正在执行事件处理函数的元素。</li>
</ul>
<p><strong>例子</strong>：<br>继续以上的 HTML 结构和事件监听器：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;parent&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">currentTarget</span>);  <span class="comment">// 打印绑定事件的元素（父元素）</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>当点击 <code>button</code> 时，<code>event.currentTarget</code> 会输出：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;child&quot;</span>&gt;</span>点击我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这是因为事件监听器绑定在父元素 <code>div</code> 上，<code>event.currentTarget</code> 始终指向 <code>div</code> 元素。</p>
<h3 id="关键区别"><a href="#关键区别" class="headerlink" title="关键区别"></a>关键区别</h3><ul>
<li><strong><code>event.target</code></strong> 是<strong>触发事件的元素</strong>，即事件发生的源头。</li>
<li><strong><code>event.currentTarget</code></strong> 是<strong>事件监听器绑定的元素</strong>，即正在处理当前事件的元素。</li>
</ul>
<h3 id="什么时候用-event-target-和-event-currentTarget？"><a href="#什么时候用-event-target-和-event-currentTarget？" class="headerlink" title="什么时候用 event.target 和 event.currentTarget？"></a>什么时候用 <code>event.target</code> 和 <code>event.currentTarget</code>？</h3><ul>
<li><strong><code>event.target</code></strong> 用来获取事件的具体目标元素，适用于你想知道事件是在哪个元素上触发的。</li>
<li><strong><code>event.currentTarget</code></strong> 用来获取事件处理函数当前绑定的元素，适用于你想知道事件是在哪个元素上被处理的，通常用于委托事件。</li>
</ul>
<h3 id="事件委托的示例"><a href="#事件委托的示例" class="headerlink" title="事件委托的示例"></a>事件委托的示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;parent&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;目标元素：&#x27;</span>, event.<span class="property">target</span>);  <span class="comment">// 目标元素是点击的子元素</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;当前处理元素：&#x27;</span>, event.<span class="property">currentTarget</span>);  <span class="comment">// 当前处理元素是父元素</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>如果你点击了 <code>button</code>，<code>event.target</code> 会是 <code>button</code> 元素，而 <code>event.currentTarget</code> 会是 <code>parent</code> 元素。</li>
</ul>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li><strong><code>event.target</code></strong>: 触发事件的实际元素。</li>
<li><strong><code>event.currentTarget</code></strong>: 当前正在处理事件的元素（监听器绑定的元素）。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/02/14/dom-event-target/" data-id="cm74iq3r60005l9ocg8m752h1" data-title="event.target 和 event.currentTarget" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DOM/" rel="tag">DOM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-dom-event-bubbling" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/02/14/dom-event-bubbling/" class="article-date">
  <time class="dt-published" datetime="2025-02-14T16:18:55.000Z" itemprop="datePublished">2025-02-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/02/14/dom-event-bubbling/">事件冒泡</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>事件冒泡（Event Bubbling）</strong> 是 DOM 事件传播的一种机制。它描述了事件从目标元素开始，逐级向上冒泡到父元素、祖先元素，直到 <code>document</code> 对象的过程。</p>
<h3 id="事件冒泡的过程"><a href="#事件冒泡的过程" class="headerlink" title="事件冒泡的过程"></a>事件冒泡的过程</h3><ol>
<li>当用户在一个元素上触发事件时，事件首先会在该元素上被处理（目标元素）。</li>
<li>然后事件会冒泡到该元素的父元素，接着是父元素的父元素，直到 <code>document</code> 对象。</li>
<li>事件会按照这个顺序进行传播，直到事件到达最顶层的元素或者被阻止。</li>
</ol>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>假设有如下的 HTML 结构：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;child&quot;</span>&gt;</span>点击我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>并且在 JavaScript 中给父元素和子元素分别绑定了事件监听器：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;parent&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&#x27;父元素被点击&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;child&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&#x27;子元素被点击&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>当你点击按钮时，事件首先会在按钮上触发（目标元素），然后冒泡到父元素 <code>div</code> 上。输出结果将是：</p>
<ol>
<li><code>&quot;子元素被点击&quot;</code>（按钮的点击事件）</li>
<li><code>&quot;父元素被点击&quot;</code>（父 <code>div</code> 的点击事件）</li>
</ol>
<h3 id="为什么叫“冒泡”？"><a href="#为什么叫“冒泡”？" class="headerlink" title="为什么叫“冒泡”？"></a>为什么叫“冒泡”？</h3><p>就像水滴从水面滴下，事件从目标元素冒泡到最顶层一样，因此叫做“事件冒泡”。</p>
<h3 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h3><p>你可以使用 <code>event.stopPropagation()</code> 来阻止事件继续冒泡到父元素。</p>
<p><strong>例子</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;child&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&#x27;子元素被点击&#x27;</span>);</span><br><span class="line">  event.<span class="title function_">stopPropagation</span>();  <span class="comment">// 阻止冒泡</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这时，点击按钮时，只会显示 <code>&quot;子元素被点击&quot;</code>，父元素的点击事件不会被触发。</p>
<h2 id="event-preventDefault-和-event-stopPropagation-的区别"><a href="#event-preventDefault-和-event-stopPropagation-的区别" class="headerlink" title="event.preventDefault() 和 event.stopPropagation()的区别"></a><code>event.preventDefault()</code> 和 <code>event.stopPropagation()</code>的区别</h2><p><code>event.preventDefault()</code> 和 <code>event.stopPropagation()</code> 都是用来控制事件流的，但它们的作用不同：</p>
<ol>
<li><p><strong><code>event.preventDefault()</code></strong>:</p>
<ul>
<li>这个方法用来<strong>阻止事件的默认行为</strong>。例如，点击一个链接时，浏览器默认会跳转到链接地址。如果你调用了 <code>event.preventDefault()</code>，浏览器就不会执行这个跳转操作。</li>
<li>它不会停止事件的传播（即事件仍然会冒泡或捕获）。</li>
</ul>
<p><strong>例子</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;form&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;submit&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  event.<span class="title function_">preventDefault</span>();  <span class="comment">// 阻止表单提交</span></span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&#x27;表单未提交&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>event.stopPropagation()</code></strong>:</p>
<ul>
<li>这个方法用来<strong>停止事件的传播</strong>，即<strong>阻止事件冒泡</strong>（从目标元素到根元素）或<strong>捕获</strong>（从根元素到目标元素）。</li>
<li>这意味着事件不会继续向上传播到父元素，也不会传递给其他监听该事件的元素。</li>
</ul>
<p><strong>例子</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  event.<span class="title function_">stopPropagation</span>();  <span class="comment">// 阻止事件冒泡</span></span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&#x27;按钮被点击&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&#x27;DIV 被点击&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，点击按钮时，只会显示 <code>&quot;按钮被点击&quot;</code>，而不会触发 <code>div</code> 的点击事件。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/02/14/dom-event-bubbling/" data-id="cm74iq3r40003l9oc189ec41q" data-title="事件冒泡" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DOM/" rel="tag">DOM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-js-debounce-throttle" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/02/12/js-debounce-throttle/" class="article-date">
  <time class="dt-published" datetime="2025-02-12T14:04:28.000Z" itemprop="datePublished">2025-02-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/02/12/js-debounce-throttle/">JavaScript 防抖（Debounce）和节流（Throttle）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>防抖（Debounce）</strong> 和 <strong>节流（Throttle）</strong> 是两种优化高频执行函数的技术，主要用于<strong>减少函数调用频率，提高性能</strong>，比如处理：</p>
<ul>
<li><strong>窗口 <code>resize</code> 事件</strong></li>
<li><strong>搜索框输入</strong></li>
<li><strong>按钮点击</strong></li>
<li><strong>滚动事件 <code>scroll</code></strong></li>
<li><strong>鼠标移动 <code>mousemove</code></strong></li>
</ul>
<hr>
<h2 id="1-防抖（Debounce）"><a href="#1-防抖（Debounce）" class="headerlink" title="1. 防抖（Debounce）"></a><strong>1. 防抖（Debounce）</strong></h2><p><strong>概念：</strong>  </p>
<blockquote>
<p><strong>防抖（Debounce）</strong> 使得某个函数在<strong>一段时间内</strong>（如 500ms）<strong>没有再次调用</strong>时才会执行。如果在等待时间内又触发了函数，则重新计时。</p>
</blockquote>
<p><strong>适用场景：</strong>  </p>
<ul>
<li><strong>搜索输入框</strong>：只在用户<strong>停止输入</strong>后才发送请求。</li>
<li><strong>窗口 <code>resize</code> 事件</strong>：用户停止调整窗口大小后执行计算。</li>
</ul>
<h3 id="🔹-防抖实现"><a href="#🔹-防抖实现" class="headerlink" title="🔹 防抖实现"></a><strong>🔹 防抖实现</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer; <span class="comment">// 计时器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer); <span class="comment">// 清除之前的定时器</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args); <span class="comment">// 在 delay 时间后执行</span></span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="🔹-使用防抖"><a href="#🔹-使用防抖" class="headerlink" title="🔹 使用防抖"></a><strong>🔹 使用防抖</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">onSearchInput</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;搜索内容：&quot;</span>, e.<span class="property">target</span>.<span class="property">value</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> debouncedSearch = <span class="title function_">debounce</span>(onSearchInput, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;search&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;input&quot;</span>, debouncedSearch);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>用户<strong>连续输入时不会触发</strong> <code>onSearchInput</code>，<strong>只有停止输入 500ms 后才执行</strong>。</p>
</blockquote>
<hr>
<h2 id="2-节流（Throttle）"><a href="#2-节流（Throttle）" class="headerlink" title="2. 节流（Throttle）"></a><strong>2. 节流（Throttle）</strong></h2><p><strong>概念：</strong>  </p>
<blockquote>
<p><strong>节流（Throttle）</strong> 使得某个函数<strong>在一定时间间隔内</strong>（如 500ms）<strong>只执行一次</strong>，无论它在这段时间内被调用了多少次。</p>
</blockquote>
<p><strong>适用场景：</strong>  </p>
<ul>
<li><strong>按钮点击</strong>：防止<strong>用户连点</strong>按钮造成重复请求。</li>
<li><strong>滚动事件</strong>：防止<strong>高频触发 <code>scroll</code></strong> 影响性能。</li>
<li>**鼠标移动 <code>mousemove</code>**：防止触发次数过多影响页面表现。</li>
</ul>
<h3 id="🔹-节流实现"><a href="#🔹-节流实现" class="headerlink" title="🔹 节流实现"></a><strong>🔹 节流实现</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, interval</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> lastTime = <span class="number">0</span>; <span class="comment">// 记录上次执行时间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">        <span class="keyword">if</span> (now - lastTime &gt;= interval) &#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">            lastTime = now; <span class="comment">// 更新上次执行时间</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="🔹-使用节流"><a href="#🔹-使用节流" class="headerlink" title="🔹 使用节流"></a><strong>🔹 使用节流</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">onScroll</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;页面滚动中...&quot;</span>, <span class="title class_">Date</span>.<span class="title function_">now</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> throttledScroll = <span class="title function_">throttle</span>(onScroll, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;scroll&quot;</span>, throttledScroll);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>即使滚动事件<strong>触发上百次</strong>，<code>onScroll</code> <strong>每隔 1000ms 只执行一次</strong>。</p>
</blockquote>
<hr>
<h2 id="3-防抖-vs-节流"><a href="#3-防抖-vs-节流" class="headerlink" title="3. 防抖 vs. 节流"></a><strong>3. 防抖 vs. 节流</strong></h2><table>
<thead>
<tr>
<th>特性</th>
<th>防抖（Debounce）</th>
<th>节流（Throttle）</th>
</tr>
</thead>
<tbody><tr>
<td>触发时机</td>
<td><strong>延迟执行</strong>（最后一次触发后执行）</td>
<td><strong>固定间隔执行</strong>（间隔时间内最多执行一次）</td>
</tr>
<tr>
<td>适用场景</td>
<td>搜索框输入、表单验证、调整窗口大小</td>
<td>按钮点击、滚动事件、鼠标移动</td>
</tr>
<tr>
<td>控制方式</td>
<td>清除 <code>setTimeout</code> 重新计时</td>
<td>记录时间戳</td>
</tr>
</tbody></table>
<hr>
<h2 id="4-进阶：节流的-setTimeout-版本"><a href="#4-进阶：节流的-setTimeout-版本" class="headerlink" title="4. 进阶：节流的 setTimeout 版本"></a><strong>4. 进阶：节流的 <code>setTimeout</code> 版本</strong></h2><p>除了 <code>Date.now()</code> 版本，我们还可以用 <code>setTimeout</code> 实现节流：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, interval</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">                timer = <span class="literal">null</span>; <span class="comment">// 清空计时器</span></span><br><span class="line">            &#125;, interval);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>区别</strong>：  </p>
</blockquote>
<ul>
<li><code>Date.now()</code> 版本<strong>立即执行</strong>，适合<strong>立即响应</strong>的场景。</li>
<li><code>setTimeout</code> 版本<strong>延迟执行</strong>，适合<strong>事件结束后响应</strong>的场景。</li>
</ul>
<hr>
<h2 id="5-结合防抖和节流"><a href="#5-结合防抖和节流" class="headerlink" title="5. 结合防抖和节流"></a><strong>5. 结合防抖和节流</strong></h2><p>有些情况我们希望：</p>
<ul>
<li><strong>短时间内的高频触发不要执行（防抖）</strong>。</li>
<li><strong>但保证一定时间内至少执行一次（节流）</strong>。</li>
</ul>
<p>可以结合两者：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttleAndDebounce</span>(<span class="params">fn, interval</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> lastTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (now - lastTime &gt;= interval) &#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">            lastTime = now;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">                lastTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">            &#125;, interval);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a><strong>6. 总结</strong></h2><ul>
<li><strong>防抖（Debounce）</strong>：多次触发只执行<strong>最后一次</strong>，适用于<strong>搜索、窗口 <code>resize</code></strong> 等场景。</li>
<li><strong>节流（Throttle）</strong>：固定间隔执行一次，适用于<strong>滚动事件、鼠标移动、按钮点击</strong>。</li>
<li><strong>可以结合防抖和节流</strong>，保证<strong>短时间内不执行，但一定时间内至少执行一次</strong>。</li>
</ul>
<hr>
<p>🔥 <strong>推荐使用场景</strong></p>
<table>
<thead>
<tr>
<th>适用场景</th>
<th>方案</th>
</tr>
</thead>
<tbody><tr>
<td>搜索框输入</td>
<td><strong>防抖（Debounce）</strong></td>
</tr>
<tr>
<td>按钮防止多次点击</td>
<td><strong>节流（Throttle）</strong></td>
</tr>
<tr>
<td>页面 <code>resize</code></td>
<td><strong>防抖（Debounce）</strong></td>
</tr>
<tr>
<td>滚动 <code>scroll</code> 事件</td>
<td><strong>节流（Throttle）</strong></td>
</tr>
<tr>
<td>鼠标 <code>mousemove</code></td>
<td><strong>节流（Throttle）</strong></td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/02/12/js-debounce-throttle/" data-id="cm74iq3rc000kl9ocebo76nr2" data-title="JavaScript 防抖（Debounce）和节流（Throttle）" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-js-iterator-generator" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/02/12/js-iterator-generator/" class="article-date">
  <time class="dt-published" datetime="2025-02-12T12:11:17.000Z" itemprop="datePublished">2025-02-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/02/12/js-iterator-generator/">JavaScript中的迭代器和生成器</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在 JavaScript 中，<strong>迭代器（Iterator）</strong> 和 <strong>生成器（Generator）</strong> 是用于 <strong>遍历数据结构</strong> 和 <strong>实现惰性计算</strong> 的强大工具。它们与 <code>for...of</code>、<code>Symbol.iterator</code> 以及 <code>yield</code> 关键字密切相关，可以帮助我们更高效地处理 <strong>流数据</strong>、<strong>自定义遍历</strong> 和 <strong>异步任务</strong>。  </p>
<hr>
<h2 id="1-迭代器（Iterator）"><a href="#1-迭代器（Iterator）" class="headerlink" title="1. 迭代器（Iterator）"></a><strong>1. 迭代器（Iterator）</strong></h2><h3 id="1-1-什么是迭代器？"><a href="#1-1-什么是迭代器？" class="headerlink" title="1.1 什么是迭代器？"></a><strong>1.1 什么是迭代器？</strong></h3><p>迭代器（Iterator）是一种 <strong>按顺序访问集合元素</strong> 的方式，但不暴露其底层实现。它提供了一个 <code>next()</code> 方法，每次调用 <code>next()</code> 都会返回一个对象：</p>
<ul>
<li><code>&#123; value: 数据, done: false &#125;</code> —— <strong>表示当前值和未完成的状态</strong></li>
<li><code>&#123; value: undefined, done: true &#125;</code> —— <strong>表示迭代结束</strong></li>
</ul>
<h3 id="1-2-迭代器的基本实现"><a href="#1-2-迭代器的基本实现" class="headerlink" title="1.2 迭代器的基本实现"></a><strong>1.2 迭代器的基本实现</strong></h3><p>迭代器本质上是一个 <strong>实现了 <code>next()</code> 方法的对象</strong>，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createIterator</span>(<span class="params">array</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">next</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; array.<span class="property">length</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123; <span class="attr">value</span>: array[index++], <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用迭代器</span></span><br><span class="line"><span class="keyword">const</span> iterator = <span class="title function_">createIterator</span>([<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: &#x27;apple&#x27;, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: &#x27;banana&#x27;, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: &#x27;cherry&#x27;, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>特点</strong></p>
<ul>
<li>迭代器不会自动迭代，而是需要手动调用 <code>next()</code>。</li>
<li>需要手动维护 <code>index</code> 变量。</li>
</ul>
<hr>
<h3 id="1-3-Symbol-iterator-和可迭代对象"><a href="#1-3-Symbol-iterator-和可迭代对象" class="headerlink" title="1.3 Symbol.iterator 和可迭代对象"></a><strong>1.3 <code>Symbol.iterator</code> 和可迭代对象</strong></h3><p>如果对象 <strong>实现了 <code>Symbol.iterator</code> 方法</strong>，它就是 <strong>可迭代对象（Iterable）</strong>，可以被 <code>for...of</code>、<code>Array.from()</code> 这样的迭代方法使用。</p>
<h4 id="1-3-1-自定义可迭代对象"><a href="#1-3-1-自定义可迭代对象" class="headerlink" title="1.3.1 自定义可迭代对象"></a><strong>1.3.1 自定义可迭代对象</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> iterable = &#123;</span><br><span class="line">    <span class="attr">data</span>: [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>],</span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">next</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> index &lt; <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">length</span></span><br><span class="line">                    ? &#123; <span class="attr">value</span>: <span class="variable language_">this</span>.<span class="property">data</span>[index++], <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">                    : &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 for...of 进行迭代</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item); <span class="comment">// one, two, three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ul>
<li><code>Symbol.iterator</code> 返回的是一个 <strong>迭代器对象</strong>，这个对象必须实现 <code>next()</code> 方法。</li>
<li><code>for...of</code> 会自动调用 <code>next()</code>，无需手动调用。</li>
</ul>
<hr>
<h3 id="1-4-JavaScript-内置可迭代对象"><a href="#1-4-JavaScript-内置可迭代对象" class="headerlink" title="1.4 JavaScript 内置可迭代对象"></a><strong>1.4 JavaScript 内置可迭代对象</strong></h3><p><strong>默认实现 <code>Symbol.iterator</code> 的数据结构</strong></p>
<ul>
<li><strong>数组（Array）</strong></li>
<li><strong>字符串（String）</strong></li>
<li><strong>Map 和 Set</strong></li>
<li><strong>TypedArray</strong></li>
<li><strong>函数参数对象（arguments）</strong></li>
<li><strong>NodeList（部分浏览器实现）</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> iter = str[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123; value: &#x27;H&#x27;, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123; value: &#x27;e&#x27;, done: false &#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-生成器（Generator）"><a href="#2-生成器（Generator）" class="headerlink" title="2. 生成器（Generator）"></a><strong>2. 生成器（Generator）</strong></h2><h3 id="2-1-什么是生成器？"><a href="#2-1-什么是生成器？" class="headerlink" title="2.1 什么是生成器？"></a><strong>2.1 什么是生成器？</strong></h3><p>生成器（Generator）是一种特殊的函数，它可以 <strong>暂停和恢复执行</strong>，使用 <code>function*</code> 关键字定义，并通过 <code>yield</code> 关键字返回多个值。</p>
<p><strong>特点</strong></p>
<ul>
<li><strong>调用生成器函数不会立即执行，而是返回一个迭代器</strong>。</li>
<li><strong>调用 <code>next()</code> 时，执行到 <code>yield</code> 语句并暂停</strong>，下次调用时从暂停的地方继续。</li>
<li><strong><code>yield</code> 返回的是一个值，而不是一个完整的对象</strong>。</li>
</ul>
<h3 id="2-2-生成器的基本使用"><a href="#2-2-生成器的基本使用" class="headerlink" title="2.2 生成器的基本使用"></a><strong>2.2 生成器的基本使用</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">myGenerator</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = <span class="title function_">myGenerator</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gen.<span class="title function_">next</span>()); <span class="comment">// &#123; value: &#x27;A&#x27;, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gen.<span class="title function_">next</span>()); <span class="comment">// &#123; value: &#x27;B&#x27;, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gen.<span class="title function_">next</span>()); <span class="comment">// &#123; value: &#x27;C&#x27;, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gen.<span class="title function_">next</span>()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>特点</strong></p>
<ul>
<li><code>yield</code> 使函数暂停执行，下次 <code>next()</code> 继续执行。</li>
<li>生成器返回的是一个 <strong>迭代器对象</strong>。</li>
</ul>
<hr>
<h3 id="2-3-for-of-遍历生成器"><a href="#2-3-for-of-遍历生成器" class="headerlink" title="2.3 for...of 遍历生成器"></a><strong>2.3 <code>for...of</code> 遍历生成器</strong></h3><p>生成器本质上是一个 <strong>可迭代对象</strong>，可以用 <code>for...of</code> 遍历：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">countUp</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> <span class="title function_">countUp</span>()) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 1, 2, 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong></p>
<ul>
<li><code>for...of</code> <strong>自动处理 <code>done</code> 状态</strong>，不需要手动调用 <code>next()</code>。</li>
</ul>
<hr>
<h3 id="2-4-生成器的应用"><a href="#2-4-生成器的应用" class="headerlink" title="2.4 生成器的应用"></a><strong>2.4 生成器的应用</strong></h3><h4 id="2-4-1-生成无限序列"><a href="#2-4-1-生成无限序列" class="headerlink" title="2.4.1 生成无限序列"></a><strong>2.4.1 生成无限序列</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">infiniteNumbers</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span> num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> infiniteGen = <span class="title function_">infiniteNumbers</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(infiniteGen.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(infiniteGen.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(infiniteGen.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p><strong>适用场景</strong></p>
<ul>
<li>生成 <strong>无限序列</strong>（如斐波那契数列）。</li>
<li>按需生成数据，节省内存。</li>
</ul>
<h4 id="2-4-2-斐波那契数列"><a href="#2-4-2-斐波那契数列" class="headerlink" title="2.4.2 斐波那契数列"></a><strong>2.4.2 斐波那契数列</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">fibonacci</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> [prev, curr] = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span> curr;</span><br><span class="line">        [prev, curr] = [curr, prev + curr];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fib = <span class="title function_">fibonacci</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fib.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fib.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fib.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fib.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-迭代器-vs-生成器"><a href="#3-迭代器-vs-生成器" class="headerlink" title="3. 迭代器 vs 生成器"></a><strong>3. 迭代器 vs 生成器</strong></h2><table>
<thead>
<tr>
<th><strong>特点</strong></th>
<th><strong>迭代器（Iterator）</strong></th>
<th><strong>生成器（Generator）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>定义方式</strong></td>
<td>手动实现 <code>next()</code></td>
<td>使用 <code>function*</code></td>
</tr>
<tr>
<td><strong>状态维护</strong></td>
<td>需要手动维护索引</td>
<td><code>yield</code> 自动管理状态</td>
</tr>
<tr>
<td><strong>惰性计算</strong></td>
<td>需要手动控制</td>
<td>默认支持</td>
</tr>
<tr>
<td><strong>代码简洁度</strong></td>
<td>代码较繁琐</td>
<td>代码更简洁</td>
</tr>
</tbody></table>
<hr>
<h2 id="4-结论"><a href="#4-结论" class="headerlink" title="4. 结论"></a><strong>4. 结论</strong></h2><ul>
<li><strong>迭代器适用于</strong> 自定义遍历逻辑，需要手动维护 <code>next()</code> 。</li>
<li><strong>生成器适用于</strong> 惰性计算、数据流处理，代码更简洁。</li>
<li><strong><code>Symbol.iterator</code> 使对象可迭代</strong>，结合 <code>for...of</code> 提供更优雅的遍历方式。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/02/12/js-iterator-generator/" data-id="cm74iq3rf000sl9ocfeq28cu0" data-title="JavaScript中的迭代器和生成器" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-js-object" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/02/11/js-object/" class="article-date">
  <time class="dt-published" datetime="2025-02-11T18:55:59.000Z" itemprop="datePublished">2025-02-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/02/11/js-object/">JavaScript中的对象</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-语法"><a href="#1-语法" class="headerlink" title="1. 语法"></a>1. 语法</h2><p>JavaScript 中的对象可以通过两种方式定义：声明形式和构造形式。</p>
<p><strong>声明形式：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  <span class="attr">key</span>: value</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>构造形式：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">myObj.<span class="property">key</span> = value;</span><br></pre></td></tr></table></figure>

<h2 id="2-类型"><a href="#2-类型" class="headerlink" title="2. 类型"></a>2. 类型</h2><p>JavaScript 中的主要数据类型包括：</p>
<ul>
<li><code>string</code></li>
<li><code>number</code></li>
<li><code>boolean</code></li>
<li><code>null</code></li>
<li><code>undefined</code></li>
<li><code>object</code></li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li><strong>基本类型</strong>（string、number、boolean、null、undefined）本身不是对象。</li>
<li><code>null</code> 不是对象，但 <code>typeof null</code> 返回 “object”，这是 JavaScript 的历史遗留 bug。</li>
<li>JavaScript 中还有许多特殊的对象子类型，可以称为<strong>复杂基本类型</strong>。</li>
</ul>
<h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><p>JavaScript 提供了一些内置对象，它们类似于其他语言中的类（class），但实际上只是构造函数：</p>
<ul>
<li><code>String</code></li>
<li><code>Number</code></li>
<li><code>Boolean</code></li>
<li><code>Object</code></li>
<li><code>Function</code></li>
<li><code>Array</code></li>
<li><code>Date</code></li>
<li><code>RegExp</code></li>
<li><code>Error</code></li>
</ul>
<h2 id="3-对象的内容"><a href="#3-对象的内容" class="headerlink" title="3. 对象的内容"></a>3. 对象的内容</h2><p>对象由<strong>属性</strong>组成，每个属性都是一个键值对，键是字符串，值可以是任何类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myObject.<span class="property">a</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myObject[<span class="string">&quot;a&quot;</span>]); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>.</code> 访问方式称为<strong>属性访问</strong>。</li>
<li><code>[]</code> 访问方式称为<strong>键访问</strong>。</li>
</ul>
<h3 id="3-1-可计算属性名"><a href="#3-1-可计算属性名" class="headerlink" title="3.1 可计算属性名"></a>3.1 可计算属性名</h3><p>ES6 允许在对象字面量中使用计算属性名。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> key = <span class="string">&quot;name&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  [key]: <span class="string">&quot;John&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myObject.<span class="property">name</span>); <span class="comment">// &quot;John&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-属性与方法"><a href="#3-2-属性与方法" class="headerlink" title="3.2 属性与方法"></a>3.2 属性与方法</h3><p>对象的属性可以存储函数，但函数本身仍然只是一个值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  <span class="attr">greet</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myObject.<span class="title function_">greet</span>()); <span class="comment">// &quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-数组"><a href="#3-3-数组" class="headerlink" title="3.3 数组"></a>3.3 数组</h3><p>数组也是对象，虽然索引通常是整数，但仍然可以添加自定义属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.<span class="property">customProperty</span> = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="property">length</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="property">customProperty</span>); <span class="comment">// &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong><br>如果向数组添加一个看起来像数字的属性，它会被转换为数值下标，而不是普通属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line">arr[<span class="string">&quot;2&quot;</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">2</span>]); <span class="comment">// &quot;hello&quot; (变成了数组索引)</span></span><br></pre></td></tr></table></figure>

<h3 id="3-4-复制对象"><a href="#3-4-复制对象" class="headerlink" title="3.4 复制对象"></a>3.4 复制对象</h3><p>对象的复制可以分为<strong>浅复制</strong>和<strong>深复制</strong>。</p>
<h4 id="浅复制"><a href="#浅复制" class="headerlink" title="浅复制"></a><strong>浅复制</strong></h4><p>浅复制只复制对象的第一层属性，嵌套对象仍然共享引用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj1);</span><br><span class="line"></span><br><span class="line">obj2.<span class="property">b</span>.<span class="property">c</span> = <span class="number">42</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">b</span>.<span class="property">c</span>); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>

<h4 id="深复制"><a href="#深复制" class="headerlink" title="深复制"></a><strong>深复制</strong></h4><p>深复制创建对象的完全独立副本。</p>
<p><strong>方法 1：使用 JSON</strong>（不适用于包含函数的对象）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj1));</span><br><span class="line"></span><br><span class="line">obj2.<span class="property">b</span>.<span class="property">c</span> = <span class="number">42</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">b</span>.<span class="property">c</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p><strong>方法 2：使用递归手动复制</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&quot;object&quot;</span> || obj === <span class="literal">null</span>) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="keyword">let</span> newObj = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      newObj[key] = <span class="title function_">deepClone</span>(obj[key]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**方法 3：使用 <code>structuredClone</code>**（现代浏览器支持）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="title function_">structuredClone</span>(obj1);</span><br><span class="line"></span><br><span class="line">obj2.<span class="property">b</span>.<span class="property">c</span> = <span class="number">42</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">b</span>.<span class="property">c</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h3 id="3-5-属性描述符"><a href="#3-5-属性描述符" class="headerlink" title="3.5 属性描述符"></a>3.5 属性描述符</h3><p>JavaScript 允许通过 <code>Object.defineProperty</code> 控制对象的属性行为。</p>
<ul>
<li><strong>Writable</strong>：属性是否可以被修改。</li>
<li><strong>Configurable</strong>：属性是否可以被删除或重新定义。</li>
<li><strong>Enumerable</strong>：属性是否可被枚举（遍历）。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&quot;a&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">42</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">a</span>); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>

<h3 id="3-6-不变性"><a href="#3-6-不变性" class="headerlink" title="3.6 不变性"></a>3.6 不变性</h3><p>JavaScript 提供了不同级别的对象不变性：</p>
<ul>
<li><strong>对象常量</strong>：使用 <code>const</code> 变量名不能变，但对象内容可变。</li>
<li><strong>禁止扩展</strong>：<code>Object.preventExtensions(obj)</code> 阻止新增属性。</li>
<li><strong>密封</strong>：<code>Object.seal(obj)</code> 使对象不可扩展，且现有属性不可删除。</li>
<li><strong>冻结</strong>：<code>Object.freeze(obj)</code> 使对象不可扩展，属性不可修改或删除。</li>
</ul>
<h3 id="3-7-Getter-和-Setter"><a href="#3-7-Getter-和-Setter" class="headerlink" title="3.7 Getter 和 Setter"></a>3.7 Getter 和 Setter</h3><p>对象默认的<code>[[Put]]</code>和<code>[[Get]]</code>操作分别可以控制属性值的设置和获取。<br>在ES5中可以使用<code>getter</code>和<code>setter</code>部分改写默认操作，但是只能应用在单个属性上，无法应用在整个对象上</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">_name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>); <span class="comment">// &quot;John&quot;</span></span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&quot;Doe&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>); <span class="comment">// &quot;Doe&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-8-存在性"><a href="#3-8-存在性" class="headerlink" title="3.8 存在性"></a>3.8 存在性</h3><p>检查对象是否具有某个属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a&quot;</span> <span class="keyword">in</span> obj); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;a&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">a</span> !== <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="4-遍历"><a href="#4-遍历" class="headerlink" title="4. 遍历"></a>4. 遍历</h2><p><code>for..in</code>循环可以用来遍历对象的可枚举属性列表<br>只有属性是可枚举的<code>enumerable:true</code>，才会出现在<code>for..in</code>列表中<br>数组上应用<code>for..in</code>循环会产生出人意料的结果，因为这种美剧不仅会包含所有数值索引，还会包含所有可枚举索引。最好只在对象上应用<code>for..in</code>循环</p>
<p>如果遍历属性的值呢？<br>ES6增加了一种用来遍历数组的<code>for..of</code>语法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> v <span class="keyword">of</span> myArray) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p><code>for..of</code>循环首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的<code>next()</code>方法来遍历所有返回值<br>数组有内置的<code>@@iterator</code>，因此<code>for..of</code>可以直接应用在数组上。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/02/11/js-object/" data-id="cm74iq3ri0012l9oc65q12jm5" data-title="JavaScript中的对象" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-js-this" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/02/11/js-this/" class="article-date">
  <time class="dt-published" datetime="2025-02-11T16:50:57.000Z" itemprop="datePublished">2025-02-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/02/11/js-this/">JavaScript 中的 this</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>JavaScript 中的 <code>this</code> 是一个关键字，它的值取决于<strong>函数的调用方式</strong>，而不是它的定义方式。许多开发者对 <code>this</code> 存在误解，尤其是在不同的调用场景下它的指向可能会变化。</p>
<hr>
<h2 id="🌟-关于-this-的常见误解"><a href="#🌟-关于-this-的常见误解" class="headerlink" title="🌟 关于 this 的常见误解"></a>🌟 <strong>关于 <code>this</code> 的常见误解</strong></h2><ol>
<li><p><strong>“<code>this</code> 指向函数的作用域”</strong> ❌<br>→ <strong>实际上</strong> <code>this</code> 并不指向词法作用域，而是取决于<strong>调用方式</strong>。</p>
</li>
<li><p><strong>“<code>this</code> 总是指向调用它的对象”</strong> ❌<br>→ <strong>不完全正确</strong>，在严格模式、独立函数调用等情况下，它可能是 <code>undefined</code> 或 <code>window</code>（浏览器）&#x2F;<code>global</code>（Node.js）。</p>
</li>
<li><p><strong>“箭头函数的 <code>this</code> 和普通函数一样”</strong> ❌<br>→ <strong>错误</strong>，箭头函数的 <code>this</code> 绑定到<strong>定义时的词法作用域</strong>，不会因为调用方式而改变。</p>
</li>
</ol>
<hr>
<h2 id="🎯-this-的不同绑定规则"><a href="#🎯-this-的不同绑定规则" class="headerlink" title="🎯 this 的不同绑定规则"></a>🎯 <strong><code>this</code> 的不同绑定规则</strong></h2><h3 id="1️⃣-默认绑定（非严格模式-vs-严格模式）"><a href="#1️⃣-默认绑定（非严格模式-vs-严格模式）" class="headerlink" title="1️⃣ 默认绑定（非严格模式 vs 严格模式）"></a>1️⃣ <strong>默认绑定（非严格模式 vs 严格模式）</strong></h3><p><strong>独立调用时</strong>（不通过对象调用）：  </p>
<ul>
<li><strong>非严格模式</strong>：<code>this</code> 指向全局对象（浏览器是 <code>window</code>，Node.js 是 <code>global</code>）。</li>
<li><strong>严格模式</strong>：<code>this</code> 为 <code>undefined</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// 非严格模式下: window / global</span></span><br><span class="line">       <span class="comment">// 严格模式下: undefined</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2️⃣-隐式绑定"><a href="#2️⃣-隐式绑定" class="headerlink" title="2️⃣ 隐式绑定"></a>2️⃣ <strong>隐式绑定</strong></h3><p>如果函数作为<strong>对象的方法</strong>调用，<code>this</code> 绑定到该对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;JavaScript&quot;</span>,</span><br><span class="line">  <span class="title function_">showName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">showName</span>(); <span class="comment">// &quot;JavaScript&quot;</span></span><br></pre></td></tr></table></figure>

<p>🚨 <strong>隐式丢失</strong>（常见问题）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = obj.<span class="property">showName</span>;</span><br><span class="line"><span class="title function_">fn</span>(); <span class="comment">// undefined（默认绑定：window 或 undefined）</span></span><br></pre></td></tr></table></figure>
<p>这里 <code>fn()</code> 独立调用，<code>this</code> 变为默认绑定。</p>
<hr>
<h3 id="3️⃣-显示绑定（call-apply-bind）"><a href="#3️⃣-显示绑定（call-apply-bind）" class="headerlink" title="3️⃣ 显示绑定（call &#x2F; apply &#x2F; bind）"></a>3️⃣ <strong>显示绑定（call &#x2F; apply &#x2F; bind）</strong></h3><ul>
<li><code>call</code> &#x2F; <code>apply</code> 直接执行函数，并显式指定 <code>this</code>。</li>
<li><code>bind</code> 返回一个新函数，绑定 <code>this</code> 但不会立即执行。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">greet.<span class="title function_">call</span>(person);  <span class="comment">// &quot;Alice&quot;</span></span><br><span class="line">greet.<span class="title function_">apply</span>(person); <span class="comment">// &quot;Alice&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> boundGreet = greet.<span class="title function_">bind</span>(person);</span><br><span class="line"><span class="title function_">boundGreet</span>(); <span class="comment">// &quot;Alice&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4️⃣-new-绑定"><a href="#4️⃣-new-绑定" class="headerlink" title="4️⃣ new 绑定"></a>4️⃣ <strong><code>new</code> 绑定</strong></h3><p>通过 <code>new</code> 关键字调用函数时：</p>
<ul>
<li><code>this</code> 绑定到<strong>新创建的对象</strong>，并返回该对象（除非手动返回其他对象）。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;John&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">name</span>); <span class="comment">// &quot;John&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="⚖-绑定规则优先级"><a href="#⚖-绑定规则优先级" class="headerlink" title="⚖ 绑定规则优先级"></a>⚖ <strong>绑定规则优先级</strong></h2><p>当多个绑定规则冲突时，按以下优先级执行：</p>
<ol>
<li><strong><code>new</code> 绑定</strong>（最高）</li>
<li><strong><code>call</code> &#x2F; <code>apply</code> &#x2F; <code>bind</code> 绑定</strong></li>
<li><strong>隐式绑定</strong></li>
<li><strong>默认绑定</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">&quot;obj1&quot;</span>, foo &#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">name</span>: <span class="string">&quot;obj2&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">obj1.<span class="property">foo</span>.<span class="title function_">call</span>(obj2); <span class="comment">// &quot;obj2&quot;（显示绑定优先于隐式绑定）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> boundFoo = foo.<span class="title function_">bind</span>(obj1);</span><br><span class="line">boundFoo.<span class="title function_">call</span>(obj2); <span class="comment">// &quot;obj1&quot;（bind 绑定无法被 call / apply 覆盖）</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🚨-绑定例外"><a href="#🚨-绑定例外" class="headerlink" title="🚨 绑定例外"></a>🚨 <strong>绑定例外</strong></h2><h3 id="🔹-绑定对象为-undefined-或-null"><a href="#🔹-绑定对象为-undefined-或-null" class="headerlink" title="🔹 绑定对象为 undefined 或 null"></a>🔹 <strong>绑定对象为 <code>undefined</code> 或 <code>null</code></strong></h3><p>在 <code>call</code>、<code>apply</code> 或 <code>bind</code> 方法中，如果显式绑定的对象是 <code>null</code> 或 <code>undefined</code>，<strong>默认会回退到全局对象</strong>（在浏览器中是 <code>window</code>，在 Node.js 中是 <code>globalThis</code>）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.<span class="title function_">call</span>(<span class="literal">null</span>); <span class="comment">// 在非严格模式下：window / globalThis</span></span><br><span class="line">foo.<span class="title function_">call</span>(<span class="literal">undefined</span>); <span class="comment">// 在非严格模式下：window / globalThis</span></span><br></pre></td></tr></table></figure>

<h4 id="严格模式下"><a href="#严格模式下" class="headerlink" title="严格模式下"></a><strong>严格模式下</strong></h4><p>在 <code>use strict</code> 模式下，绑定 <code>null</code> 或 <code>undefined</code> 会保持 <code>this</code> 为 <code>null</code> 或 <code>undefined</code>，不会回退到全局对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.<span class="title function_">call</span>(<span class="literal">null</span>); <span class="comment">// null</span></span><br><span class="line">foo.<span class="title function_">call</span>(<span class="literal">undefined</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="🔹-间接引用（Implicit-Reference）"><a href="#🔹-间接引用（Implicit-Reference）" class="headerlink" title="🔹 间接引用（Implicit Reference）"></a>🔹 <strong>间接引用（Implicit Reference）</strong></h3><p><strong>间接引用</strong>指的是当属性访问的结果是一个对象的方法时，**<code>this</code> 绑定的是该方法所属的对象<strong>，但</strong>如果赋值给一个变量后调用，<code>this</code> 可能会丢失**。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简介引用：`this` 绑定到 `obj`</span></span><br><span class="line">obj.<span class="title function_">getName</span>(); <span class="comment">// &quot;Alice&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn = obj.<span class="property">getName</span>; <span class="comment">// `fn` 赋值后丢失 `this` 绑定</span></span><br><span class="line"><span class="title function_">fn</span>(); <span class="comment">// `this` 变成默认绑定（非严格模式下是 `window`，严格模式下是 `undefined`）</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="🔹-软绑定（Soft-Binding）"><a href="#🔹-软绑定（Soft-Binding）" class="headerlink" title="🔹 软绑定（Soft Binding）"></a>🔹 <strong>软绑定（Soft Binding）</strong></h3><p>软绑定（Soft Binding）是一种在 <code>this</code> 绑定丢失时<strong>提供默认对象</strong>的方法，防止 <code>this</code> 变成 <code>undefined</code> 或 <code>window</code>。</p>
<p>通常，我们可以通过<strong>封装一个自定义 <code>bind</code> 方法</strong>来实现软绑定：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">softBind</span>) &#123;</span><br><span class="line">  <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">softBind</span> = <span class="keyword">function</span> (<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> fn = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">const</span> boundArgs = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(</span><br><span class="line">        (!<span class="variable language_">this</span> || <span class="variable language_">this</span> === <span class="variable language_">window</span> || <span class="variable language_">this</span> === globalThis) ? obj : <span class="variable language_">this</span>,</span><br><span class="line">        boundArgs.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>))</span><br><span class="line">      );</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="软绑定的作用"><a href="#软绑定的作用" class="headerlink" title="软绑定的作用"></a><strong>软绑定的作用</strong></h4><ol>
<li>如果 <code>this</code> 被默认绑定（如独立调用），则使用提供的默认对象。</li>
<li>如果 <code>this</code> 是一个具体的对象，则不影响。</li>
</ol>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultObj = &#123; <span class="attr">name</span>: <span class="string">&quot;Default&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> boundGreet = greet.<span class="title function_">softBind</span>(defaultObj);</span><br><span class="line"></span><br><span class="line"><span class="title function_">boundGreet</span>(); <span class="comment">// &quot;Default&quot;（因为 `this` 绑定丢失）</span></span><br><span class="line">boundGreet.<span class="title function_">call</span>(person); <span class="comment">// &quot;John&quot;（因为 `this` 绑定到 `person`）</span></span><br></pre></td></tr></table></figure>

<h4 id="软绑定-vs-bind"><a href="#软绑定-vs-bind" class="headerlink" title="软绑定 vs bind"></a><strong>软绑定 vs <code>bind</code></strong></h4><ul>
<li><code>bind()</code> 会创建一个<strong>永久绑定</strong>，无论怎么调用 <code>this</code> 都不会改变。</li>
<li>软绑定<strong>只在 <code>this</code> 绑定丢失时</strong>提供默认值，不会覆盖已有绑定。</li>
</ul>
<hr>
<h2 id="🎯-箭头函数中的-this（词法作用域）"><a href="#🎯-箭头函数中的-this（词法作用域）" class="headerlink" title="🎯 箭头函数中的 this（词法作用域）"></a>🎯 <strong>箭头函数中的 <code>this</code>（词法作用域）</strong></h2><p>箭头函数的 <code>this</code> 取决于<strong>定义位置</strong>，不会因调用方式改变。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">method</span>: <span class="title function_">outer</span>() &#125;;</span><br><span class="line">obj.<span class="title function_">method</span>(); <span class="comment">// outer() 的 `this` 绑定于定义时的作用域，而非 obj</span></span><br></pre></td></tr></table></figure>

<p>✅ <strong>常见用途</strong>：避免 <code>this</code> 丢失</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">seconds</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">seconds</span>++;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">seconds</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Timer</span>(); <span class="comment">// `this` 绑定 Timer 实例，而不是 `setInterval` 内部</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ <strong>总结</strong></h2><table>
<thead>
<tr>
<th>绑定方式</th>
<th><code>this</code> 指向</th>
</tr>
</thead>
<tbody><tr>
<td><strong>默认绑定</strong></td>
<td><code>window</code>（非严格）&#x2F; <code>undefined</code>（严格模式）</td>
</tr>
<tr>
<td><strong>隐式绑定</strong></td>
<td>调用它的对象</td>
</tr>
<tr>
<td><strong>显示绑定</strong>（<code>call</code> &#x2F; <code>apply</code> &#x2F; <code>bind</code>）</td>
<td>绑定的对象</td>
</tr>
<tr>
<td><strong><code>new</code> 绑定</strong></td>
<td>新创建的对象</td>
</tr>
<tr>
<td><strong>箭头函数</strong></td>
<td>继承外部作用域的 <code>this</code>（词法绑定）</td>
</tr>
</tbody></table>
<p>🔹 <strong>优先级：<code>new</code> 绑定 &gt; <code>call</code> &#x2F; <code>apply</code> &#x2F; <code>bind</code> &gt; 隐式绑定 &gt; 默认绑定</strong><br>🔹 <strong>箭头函数不绑定 <code>this</code>，它继承外层作用域的 <code>this</code></strong>  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/02/11/js-this/" data-id="cm74iq3rk0019l9oc3woqb1xr" data-title="JavaScript 中的 this" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-js-closure" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/02/10/js-closure/" class="article-date">
  <time class="dt-published" datetime="2025-02-10T16:26:37.000Z" itemprop="datePublished">2025-02-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/02/10/js-closure/">JavaScript中的闭包</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="闭包（Closure）简介"><a href="#闭包（Closure）简介" class="headerlink" title="闭包（Closure）简介"></a>闭包（Closure）简介</h3><p>闭包（Closure）是 JavaScript 中的一个非常重要的概念，它指的是一个函数和它的词法环境（即函数定义时的作用域）绑定在一起的现象。换句话说，闭包使得一个函数可以访问其外部函数的变量，即使外部函数已经执行完毕。</p>
<h3 id="闭包的形成"><a href="#闭包的形成" class="headerlink" title="闭包的形成"></a>闭包的形成</h3><p>闭包的形成需要满足两个条件：</p>
<ol>
<li><strong>函数内部定义了另一个函数</strong>。</li>
<li><strong>内层函数引用了外层函数的变量</strong>。</li>
</ol>
<h3 id="闭包的特点"><a href="#闭包的特点" class="headerlink" title="闭包的特点"></a>闭包的特点</h3><ul>
<li><strong>访问外部变量</strong>：闭包允许内层函数访问外层函数的变量，即使外层函数已经执行完毕。</li>
<li><strong>持有外部环境的引用</strong>：内层函数持有外层函数作用域的引用，所以即使外层函数已经返回，外层函数的变量依然会存在。</li>
</ul>
<h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;  <span class="comment">// 外部函数的局部变量</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params"></span>) &#123;  <span class="comment">// 返回一个内部函数</span></span><br><span class="line">    count++;  <span class="comment">// 内部函数可以访问外部函数的局部变量</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = <span class="title function_">outer</span>();  <span class="comment">// 调用外部函数，返回内部函数</span></span><br><span class="line"><span class="title function_">counter</span>();  <span class="comment">// 输出 1</span></span><br><span class="line"><span class="title function_">counter</span>();  <span class="comment">// 输出 2</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>inner</code> 函数是 <code>outer</code> 函数的闭包，它能够访问 <code>outer</code> 函数中的 <code>count</code> 变量。即使 <code>outer</code> 函数已经执行结束，<code>count</code> 变量依然存在，因为 <code>inner</code> 函数仍然持有对 <code>count</code> 的引用。</p>
<h3 id="闭包的常见用途"><a href="#闭包的常见用途" class="headerlink" title="闭包的常见用途"></a>闭包的常见用途</h3><ol>
<li><strong>数据封装</strong>：使用闭包可以创建私有变量，使得外部代码无法直接访问和修改这些变量，只能通过闭包提供的方法访问或修改。</li>
</ol>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;  <span class="comment">// 私有变量</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">increment</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      count++;</span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">decrement</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      count--;</span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">getCount</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = <span class="title function_">createCounter</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter.<span class="title function_">increment</span>());  <span class="comment">// 输出 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter.<span class="title function_">getCount</span>());   <span class="comment">// 输出 1</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>延迟执行</strong>：闭包常用于异步编程，如回调函数或事件处理程序中。由于闭包可以保持对外部环境的引用，它能够确保在未来某个时刻访问这些变量时，值不会丢失。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/02/10/js-closure/" data-id="cm74iq3rb000gl9ocdrn02yp0" data-title="JavaScript中的闭包" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-js-hoisting" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/02/10/js-hoisting/" class="article-date">
  <time class="dt-published" datetime="2025-02-10T13:56:02.000Z" itemprop="datePublished">2025-02-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/02/10/js-hoisting/">JavaScript 提升（Hoisting）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-什么是提升？"><a href="#1-什么是提升？" class="headerlink" title="1. 什么是提升？"></a>1. 什么是提升？</h2><p><strong>提升（Hoisting）</strong> 是指 JavaScript 在执行代码之前，会<strong>将变量和函数的声明提升到当前作用域的最顶端</strong>。但变量的<strong>赋值不会被提升</strong>，这可能会导致一些意想不到的行为。</p>
<hr>
<h2 id="2-JavaScript-代码执行过程"><a href="#2-JavaScript-代码执行过程" class="headerlink" title="2. JavaScript 代码执行过程"></a>2. JavaScript 代码执行过程</h2><p>JavaScript 代码执行分为两个阶段：</p>
<ol>
<li><p><strong>编译阶段（Parsing &amp; Compilation）</strong></p>
<ul>
<li>变量和函数声明被存入内存。</li>
<li><code>var</code> 声明的变量会被默认初始化为 <code>undefined</code>。</li>
<li>函数声明会完整提升，允许在定义前调用。</li>
</ul>
</li>
<li><p><strong>执行阶段（Execution）</strong></p>
<ul>
<li>代码按照书写顺序执行。</li>
<li>变量赋值发生在此阶段。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="3-变量提升"><a href="#3-变量提升" class="headerlink" title="3. 变量提升"></a>3. 变量提升</h2><h3 id="3-1-var-变量的提升"><a href="#3-1-var-变量的提升" class="headerlink" title="3.1 var 变量的提升"></a>3.1 <code>var</code> 变量的提升</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// undefined（变量提升，但未赋值）</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<h4 id="3-1-1-编译器如何处理"><a href="#3-1-1-编译器如何处理" class="headerlink" title="3.1.1 编译器如何处理"></a>3.1.1 编译器如何处理</h4><ul>
<li><strong>编译阶段</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaScript 解释器看到 `var a = 10;`，会将 `var a;` 提升到顶部：</span></span><br><span class="line"><span class="keyword">var</span> a;  <span class="comment">// 变量声明被提升，但不会赋值</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>执行阶段</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// undefined（变量已经存在，但未赋值）</span></span><br><span class="line">a = <span class="number">10</span>;         <span class="comment">// 赋值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<h4 id="3-1-2-结论"><a href="#3-1-2-结论" class="headerlink" title="3.1.2 结论"></a>3.1.2 结论</h4><ul>
<li><code>var</code>声明的变量会被<strong>提升</strong>，但不会提升赋值部分，所以会得到<code>undefined</code></li>
</ul>
<h3 id="3-2-let-和-const-的提升"><a href="#3-2-let-和-const-的提升" class="headerlink" title="3.2 let 和 const 的提升"></a>3.2 <code>let</code> 和 <code>const</code> 的提升</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// ❌ ReferenceError: Cannot access &#x27;b&#x27; before initialization</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-1-编译器如何处理"><a href="#3-2-1-编译器如何处理" class="headerlink" title="3.2.1 编译器如何处理"></a>3.2.1 编译器如何处理</h4><ul>
<li><strong>编译阶段</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b;  <span class="comment">// 变量 b 被存储，但不会初始化</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>执行阶段</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// ❌ 访问 b 时会报错（进入 &quot;暂时性死区&quot;）</span></span><br><span class="line">b = <span class="number">20</span>; <span class="comment">// 赋值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-结论"><a href="#3-2-2-结论" class="headerlink" title="3.2.2 结论"></a>3.2.2 结论</h4><ul>
<li><code>let</code> 和 <code>const</code> 也会被提升，但不会初始化。</li>
<li>在变量声明之前访问 <code>let</code> 或 <code>const</code> 变量会触发 **”暂时性死区（Temporal Dead Zone, TDZ）”**，导致 <code>ReferenceError</code>。</li>
</ul>
<hr>
<h2 id="4-函数提升"><a href="#4-函数提升" class="headerlink" title="4. 函数提升"></a>4. 函数提升</h2><h3 id="4-1-函数声明（Function-Declaration）"><a href="#4-1-函数声明（Function-Declaration）" class="headerlink" title="4.1 函数声明（Function Declaration）"></a><strong>4.1 函数声明（Function Declaration）</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">foo</span>(); <span class="comment">// ✅ 输出 &quot;Hello&quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-1-编译器如何处理"><a href="#4-1-1-编译器如何处理" class="headerlink" title="4.1.1 编译器如何处理"></a>4.1.1 编译器如何处理</h4><ul>
<li><strong>编译阶段</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125; <span class="comment">// 函数整个被提升</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>执行阶段</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">foo</span>(); <span class="comment">// &quot;Hello&quot; ✅ 可以在定义前调用</span></span><br></pre></td></tr></table></figure>

<h4 id="4-1-2-结论"><a href="#4-1-2-结论" class="headerlink" title="4.1.2 结论"></a>4.1.2 结论</h4><ul>
<li>函数声明会被<strong>完整提升</strong>，包括函数体，因此可以在<strong>定义前调用</strong>。</li>
</ul>
<h3 id="4-2-函数表达式（Function-Expression）"><a href="#4-2-函数表达式（Function-Expression）" class="headerlink" title="4.2 函数表达式（Function Expression）"></a><strong>4.2 函数表达式（Function Expression）</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">bar</span>(); <span class="comment">// ❌ TypeError: bar is not a function</span></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-1-编译器如何处理"><a href="#4-2-1-编译器如何处理" class="headerlink" title="4.2.1 编译器如何处理"></a><strong>4.2.1 编译器如何处理</strong></h4><ul>
<li><strong>编译阶段</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar; <span class="comment">// 变量 bar 被提升，但未赋值</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>执行阶段</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">bar</span>(); <span class="comment">// ❌ 这里 bar 还是 undefined，所以会报错</span></span><br><span class="line">bar = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-2-结论"><a href="#4-2-2-结论" class="headerlink" title="4.2.2 结论"></a>4.2.2 结论</h4><ul>
<li>只有 <code>var</code> 声明的变量部分会被提升，而函数赋值不会被提升。</li>
<li>访问 <code>var</code> 声明的函数表达式变量时，值是 <code>undefined</code>，调用时会触发 <code>TypeError</code>。</li>
</ul>
<hr>
<h2 id="5-关键总结"><a href="#5-关键总结" class="headerlink" title="5. 关键总结"></a>5. 关键总结</h2><table>
<thead>
<tr>
<th>变量&#x2F;函数类型</th>
<th>是否提升？</th>
<th>是否初始化？</th>
<th>是否可提前使用？</th>
</tr>
</thead>
<tbody><tr>
<td><code>var</code> 变量</td>
<td>✅ 是</td>
<td>✅ <code>undefined</code></td>
<td>⚠️ 只能访问 <code>undefined</code></td>
</tr>
<tr>
<td><code>let</code> 变量</td>
<td>✅ 是</td>
<td>❌ 否（TDZ）</td>
<td>❌ 访问会报错</td>
</tr>
<tr>
<td><code>const</code> 变量</td>
<td>✅ 是</td>
<td>❌ 否（TDZ）</td>
<td>❌ 访问会报错</td>
</tr>
<tr>
<td>函数声明 <code>function foo() &#123;&#125;</code></td>
<td>✅ 是</td>
<td>✅ 是</td>
<td>✅ 可以提前调用</td>
</tr>
<tr>
<td>函数表达式 <code>var bar = function() &#123;&#125;</code></td>
<td>✅ 是（<code>var bar</code> 提升）</td>
<td>❌ 否</td>
<td>❌ 访问 <code>undefined</code>，调用时报错</td>
</tr>
</tbody></table>
<hr>
<h2 id="6-最佳实践"><a href="#6-最佳实践" class="headerlink" title="6. 最佳实践"></a>6. 最佳实践</h2><ol>
<li>**使用 <code>let</code> 和 <code>const</code> 代替 <code>var</code>**，避免变量提升带来的问题。</li>
<li><strong>变量声明尽量放在作用域的顶部</strong>，减少意外行为。</li>
<li><strong>在调用前定义函数</strong>，提高代码可读性和可维护性。</li>
<li><strong>避免在块级作用域外访问 <code>let</code> 或 <code>const</code> 变量</strong>，防止 <code>TDZ</code> 错误。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/02/10/js-hoisting/" data-id="cm74iq3re000nl9oc6u6l1l9i" data-title="JavaScript 提升（Hoisting）" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-js-lexical-scope" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/02/06/js-lexical-scope/" class="article-date">
  <time class="dt-published" datetime="2025-02-06T09:59:19.000Z" itemprop="datePublished">2025-02-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/02/06/js-lexical-scope/">JavaScript 的词法作用域（Lexical Scope）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="1-什么是词法作用域？"><a href="#1-什么是词法作用域？" class="headerlink" title="1. 什么是词法作用域？"></a><strong>1. 什么是词法作用域？</strong></h3><p><strong>词法作用域（Lexical Scope）</strong> 是指 <strong>变量的作用域</strong> 在 <strong>代码编写时</strong> 就已经确定，而不是在代码运行时动态决定的。</p>
<p>换句话说，<strong>作用域由代码的嵌套结构决定，而不是由函数调用方式决定</strong>。</p>
<hr>
<h3 id="2-词法作用域示例"><a href="#2-词法作用域示例" class="headerlink" title="2. 词法作用域示例"></a><strong>2. 词法作用域示例</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 词法作用域：inner() 可以访问 outer() 里的变量 a</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">inner</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">outer</span>(); <span class="comment">// 输出：Hello</span></span><br></pre></td></tr></table></figure>
<p>🔹 <strong>解释：</strong></p>
<ul>
<li><code>inner()</code> 是 <strong>定义在 <code>outer()</code> 内部</strong> 的，所以 <code>inner()</code> 可以访问 <code>outer()</code> 作用域中的变量 <code>a</code>。</li>
<li><code>a</code> 在 <code>inner()</code> <strong>外部作用域定义，但仍然可以被访问</strong>，这就是 <strong>词法作用域</strong>。</li>
</ul>
<hr>
<h3 id="3-词法作用域-vs-动态作用域"><a href="#3-词法作用域-vs-动态作用域" class="headerlink" title="3. 词法作用域 vs 动态作用域"></a><strong>3. 词法作用域 vs 动态作用域</strong></h3><h4 id="🔹-词法作用域（JavaScript-使用）"><a href="#🔹-词法作用域（JavaScript-使用）" class="headerlink" title="🔹 词法作用域（JavaScript 使用）"></a><strong>🔹 词法作用域（JavaScript 使用）</strong></h4><p>作用域在 <strong>定义时</strong> 确定，与 <strong>调用方式无关</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> inner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn = <span class="title function_">outer</span>(); <span class="comment">// `fn` 现在是 `inner` 函数</span></span><br><span class="line"><span class="title function_">fn</span>(); <span class="comment">// 输出：Hello</span></span><br></pre></td></tr></table></figure>
<p>即使 <code>fn</code> 在 <code>outer()</code> 执行完后才调用，它仍然能访问 <code>outer()</code> 作用域中的 <code>a</code>，因为 <strong>作用域在定义时就已确定</strong>。</p>
<h4 id="🔹-动态作用域（JavaScript-不使用）"><a href="#🔹-动态作用域（JavaScript-不使用）" class="headerlink" title="🔹 动态作用域（JavaScript 不使用）"></a><strong>🔹 动态作用域（JavaScript 不使用）</strong></h4><p>一些编程语言（如 Bash、Perl 早期版本）使用 <strong>动态作用域（Dynamic Scope）</strong>，即 <strong>作用域取决于函数的调用位置</strong>，而不是定义位置。但 <strong>JavaScript 不使用动态作用域</strong>，而是 <strong>词法作用域</strong>。</p>
<hr>
<h3 id="4-嵌套作用域（作用域链）"><a href="#4-嵌套作用域（作用域链）" class="headerlink" title="4. 嵌套作用域（作用域链）"></a><strong>4. 嵌套作用域（作用域链）</strong></h3><p>JavaScript 的作用域是 <strong>嵌套</strong> 的，每个函数定义时都会“记住”它创建时的作用域。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> globalVar = <span class="string">&quot;I am global&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> outerVar = <span class="string">&quot;I am outer&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> innerVar = <span class="string">&quot;I am inner&quot;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(globalVar); <span class="comment">// ✅ 访问全局作用域变量</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(outerVar);  <span class="comment">// ✅ 访问外部作用域变量</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(innerVar);  <span class="comment">// ✅ 访问自身作用域变量</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">inner</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">outer</span>();</span><br></pre></td></tr></table></figure>
<p>🔹 <strong>作用域链查找顺序：</strong></p>
<ol>
<li>先在 <code>inner()</code> 内查找变量。</li>
<li>如果找不到，就往 <code>outer()</code> 作用域查找。</li>
<li>如果还找不到，就往 <strong>全局作用域</strong> 查找。</li>
<li>找不到就报错 <code>ReferenceError</code>。</li>
</ol>
<hr>
<h3 id="5-块级作用域"><a href="#5-块级作用域" class="headerlink" title="5. 块级作用域"></a><strong>5. 块级作用域</strong></h3><p>ES6 之前，JavaScript 只有 <strong>函数作用域（Function Scope）</strong>，但 ES6 引入了 <code>let</code> 和 <code>const</code>，支持 <strong>块级作用域（Block Scope）</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">const</span> y = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// ❌ ReferenceError: x is not defined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(y); <span class="comment">// ❌ ReferenceError: y is not defined</span></span><br></pre></td></tr></table></figure>
<p>🔹 <strong>作用域类型：</strong></p>
<ul>
<li><code>var</code>：<strong>函数作用域</strong></li>
<li><code>let</code> &#x2F; <code>const</code>：<strong>块级作用域</strong></li>
<li><code>function</code>：<strong>函数作用域</strong></li>
<li><code>&#123;&#125;</code>（代码块）：<strong>块级作用域（仅 <code>let</code> 和 <code>const</code>）</strong></li>
</ul>
<hr>
<h3 id="6-闭包与词法作用域"><a href="#6-闭包与词法作用域" class="headerlink" title="6. 闭包与词法作用域"></a><strong>6. 闭包与词法作用域</strong></h3><p><strong>闭包（Closure）</strong> 是 <strong>函数可以“记住”其定义时的作用域，即使函数在作用域外调用</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params"></span>) &#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = <span class="title function_">outer</span>();</span><br><span class="line"><span class="title function_">counter</span>(); <span class="comment">// 输出：1</span></span><br><span class="line"><span class="title function_">counter</span>(); <span class="comment">// 输出：2</span></span><br></pre></td></tr></table></figure>
<p>🔹 <code>inner()</code> 记住了 <code>outer()</code> 的作用域，即使 <code>outer()</code> 已经执行完毕，<code>count</code> 仍然保留在内存中。这就是 <strong>闭包的作用</strong>，它依赖于 <strong>词法作用域</strong>。</p>
<hr>
<h3 id="7-词法作用域总结"><a href="#7-词法作用域总结" class="headerlink" title="7. 词法作用域总结"></a><strong>7. 词法作用域总结</strong></h3><p>✅ <strong>作用域在代码编写时就已确定，而不是运行时决定</strong>。<br>✅ <strong>内部函数可以访问外部作用域的变量（作用域链）</strong>。<br>✅ <strong>JavaScript 不是动态作用域，而是词法作用域</strong>。<br>✅ <strong>闭包（Closure）依赖词法作用域，使得函数可以记住创建时的作用域</strong>。  </p>
<hr>
<h3 id="8-常见问题"><a href="#8-常见问题" class="headerlink" title="8. 常见问题"></a><strong>8. 常见问题</strong></h3><h4 id="1-下面代码的输出是什么？"><a href="#1-下面代码的输出是什么？" class="headerlink" title="(1) 下面代码的输出是什么？"></a><strong>(1) 下面代码的输出是什么？</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>();</span><br></pre></td></tr></table></figure>
<p>✅ **输出：<code>undefined</code>**（不是 <code>10</code>！）<br>🔹 <strong>原因</strong>：  </p>
<ul>
<li>JavaScript 变量提升（Hoisting）：<code>var a</code> 被提升到 <code>test()</code> 作用域顶部，默认为 <code>undefined</code>，但赋值 <code>20</code> 发生在 <code>console.log(a)</code> 之后。</li>
</ul>
<p>等价于：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a; <span class="comment">// 变量提升，默认值 `undefined`</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// undefined</span></span><br><span class="line">  a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-如何让-setTimeout-循环正确打印-0-1-2-3-4？"><a href="#2-如何让-setTimeout-循环正确打印-0-1-2-3-4？" class="headerlink" title="(2) 如何让 setTimeout 循环正确打印 0, 1, 2, 3, 4？"></a><strong>(2) 如何让 <code>setTimeout</code> 循环正确打印 <code>0, 1, 2, 3, 4</code>？</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(i), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>🔴 <strong>错误输出：<code>5, 5, 5, 5, 5</code></strong></p>
<ul>
<li>因为 <code>var</code> 是 <strong>函数作用域</strong>，循环结束后，<code>i</code> 的值是 <code>5</code>，所有 <code>setTimeout</code> 共享同一个 <code>i</code>。</li>
</ul>
<p>✅ <strong>解决方法：使用 <code>let</code></strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(i), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>✅ <strong>或者使用闭包</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="keyword">function</span> (<span class="params">j</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(j), <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/02/06/js-lexical-scope/" data-id="cm74iq3rg000vl9oce42sgwyi" data-title="JavaScript 的词法作用域（Lexical Scope）" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-js-lhs-rhs" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/02/05/js-lhs-rhs/" class="article-date">
  <time class="dt-published" datetime="2025-02-05T17:29:07.000Z" itemprop="datePublished">2025-02-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/02/05/js-lhs-rhs/">JavaScript中LHS和RHS的区别</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在 JavaScript 中，<strong>LHS（Left-Hand Side）</strong> 和 <strong>RHS（Right-Hand Side）</strong> 主要用于描述变量查询的类型，通常出现在 <strong>作用域解析（Scope Resolution）</strong> 过程中。它们的概念来自于 JavaScript 引擎在执行代码时查找变量的方式。</p>
<hr>
<h2 id="LHS-查询"><a href="#LHS-查询" class="headerlink" title="LHS 查询"></a><strong>LHS 查询</strong></h2><p>LHS（左侧查询）用于查找<strong>变量的赋值目标</strong>，即<strong>变量出现在赋值运算符的左侧</strong>。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span>; <span class="comment">// &#x27;a&#x27; 进行 LHS 查询</span></span><br><span class="line">    b = <span class="number">20</span>; <span class="comment">// &#x27;b&#x27; 进行 LHS 查询（但 &#x27;b&#x27; 未声明，会变成全局变量或报错）</span></span><br><span class="line">    a++; <span class="comment">// &#x27;a&#x27; 进行 LHS 查询（相当于 a = a + 1）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LHS 查询的目标是<strong>找到变量的容器，以便对其赋值</strong>。</p>
<h3 id="RHS-查询"><a href="#RHS-查询" class="headerlink" title="RHS 查询"></a><strong>RHS 查询</strong></h3><p>RHS（右侧查询）用于<strong>获取变量的值</strong>，即<strong>变量出现在赋值运算符的右侧或作为表达式的一部分</strong>。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">demo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">5</span>; <span class="comment">// &#x27;x&#x27; 进行 LHS 查询</span></span><br><span class="line">    <span class="keyword">var</span> y = x + <span class="number">10</span>; <span class="comment">// &#x27;x&#x27; 进行 RHS 查询，因为需要获取 x 的值</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(y); <span class="comment">// &#x27;y&#x27; 进行 RHS 查询，因为 console.log 需要 y 的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RHS 查询的目标是<strong>找到变量的值，以便使用它</strong>。</p>
<h3 id="LHS-vs-RHS-具体示例"><a href="#LHS-vs-RHS-具体示例" class="headerlink" title="LHS vs RHS 具体示例"></a><strong>LHS vs RHS 具体示例</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">5</span>;    <span class="comment">// &#x27;a&#x27; 进行 LHS 查询</span></span><br><span class="line">    <span class="keyword">var</span> b = a + <span class="number">2</span>; <span class="comment">// &#x27;a&#x27; 进行 RHS 查询，&#x27;b&#x27; 进行 LHS 查询</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// &#x27;b&#x27; 进行 RHS 查询</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>代码</th>
<th>LHS 查询</th>
<th>RHS 查询</th>
</tr>
</thead>
<tbody><tr>
<td><code>var a = 5;</code></td>
<td><code>a</code></td>
<td>无</td>
</tr>
<tr>
<td><code>var b = a + 2;</code></td>
<td><code>b</code></td>
<td><code>a</code></td>
</tr>
<tr>
<td><code>console.log(b);</code></td>
<td>无</td>
<td><code>b</code></td>
</tr>
</tbody></table>
<h2 id="LHS-查询失败的后果"><a href="#LHS-查询失败的后果" class="headerlink" title="LHS 查询失败的后果"></a><strong>LHS 查询失败的后果</strong></h2><h3 id="1-在非严格模式下（非-use-strict）"><a href="#1-在非严格模式下（非-use-strict）" class="headerlink" title="1. 在非严格模式下（非 use strict）"></a><strong>1. 在非严格模式下（非 <code>use strict</code>）</strong></h3><ul>
<li>如果 LHS 查询的变量未声明，JavaScript 会<strong>默认创建一个全局变量</strong>。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">    x = <span class="number">100</span>; <span class="comment">// &#x27;x&#x27; 进行 LHS 查询，但未声明，因此变成全局变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 100 （x 变成了全局变量）</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-在严格模式下（use-strict）"><a href="#2-在严格模式下（use-strict）" class="headerlink" title="2. 在严格模式下（use strict）"></a><strong>2. 在严格模式下（<code>use strict</code>）</strong></h3><ul>
<li>LHS 查询找不到变量时会抛出 <code>ReferenceError</code>。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">    y = <span class="number">200</span>; <span class="comment">// LHS 查询失败，抛出 ReferenceError</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>(); <span class="comment">// Uncaught ReferenceError: y is not defined</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="RHS-查询失败的后果"><a href="#RHS-查询失败的后果" class="headerlink" title="RHS 查询失败的后果"></a><strong>RHS 查询失败的后果</strong></h2><ul>
<li>**如果 RHS 查询的变量未找到，JavaScript 会抛出 <code>ReferenceError</code>**。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(z); <span class="comment">// RHS 查询失败，抛出 ReferenceError</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>(); <span class="comment">// Uncaught ReferenceError: z is not defined</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><table>
<thead>
<tr>
<th>查询类型</th>
<th>作用</th>
<th>失败时的行为</th>
</tr>
</thead>
<tbody><tr>
<td><strong>LHS 查询</strong></td>
<td>查找<strong>变量的存储位置</strong>，用于<strong>赋值</strong></td>
<td><strong>非严格模式</strong>：创建全局变量<br><strong>严格模式</strong>：<code>ReferenceError</code></td>
</tr>
<tr>
<td><strong>RHS 查询</strong></td>
<td>查找<strong>变量的值</strong>，用于<strong>读取</strong></td>
<td><code>ReferenceError</code></td>
</tr>
</tbody></table>
<p>LHS 主要用于赋值操作，而 RHS 主要用于取值操作。理解它们对于<strong>作用域解析</strong>和<strong>错误调试</strong>非常重要！ 🚀</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/02/05/js-lhs-rhs/" data-id="cm74iq3rh000yl9oc8tt849v0" data-title="JavaScript中LHS和RHS的区别" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Swift/">Swift</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bug/" rel="tag">Bug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DOM/" rel="tag">DOM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/" rel="tag">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Swift/" rel="tag">Swift</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/" rel="tag">iOS</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 10px;">Android</a> <a href="/tags/Bug/" style="font-size: 10px;">Bug</a> <a href="/tags/DOM/" style="font-size: 13.33px;">DOM</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/React/" style="font-size: 10px;">React</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/Swift/" style="font-size: 10px;">Swift</a> <a href="/tags/iOS/" style="font-size: 16.67px;">iOS</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/02/">February 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/02/14/dom-event-target/">event.target 和 event.currentTarget</a>
          </li>
        
          <li>
            <a href="/2025/02/14/dom-event-bubbling/">事件冒泡</a>
          </li>
        
          <li>
            <a href="/2025/02/12/js-debounce-throttle/">JavaScript 防抖（Debounce）和节流（Throttle）</a>
          </li>
        
          <li>
            <a href="/2025/02/12/js-iterator-generator/">JavaScript中的迭代器和生成器</a>
          </li>
        
          <li>
            <a href="/2025/02/11/js-object/">JavaScript中的对象</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 xuexiangxu<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>